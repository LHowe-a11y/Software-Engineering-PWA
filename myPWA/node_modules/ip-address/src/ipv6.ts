/* eslint-disable prefer-destructuring */
/* eslint-disable no-param-reassign */

import * as common from './common';
import * as constants4 from './v4/constants';
import * as constants6 from './v6/constants';
import * as helpers from './v6/helpers';
import { Address4 } from './ipv4';
import {
  ADDRESS_BOUNDARY,
  possibleElisions,
  simpleRegularExpression,
} from './v6/regular-expressions';
import { AddressError } from './address-error';
import { BigInteger } from 'jsbn';
import { sprintf } from 'sprintf-js';

function assert(condition: any): asserts condition {
  if (!condition) {
    throw new Error('Assertion failed.');
  }
}

function addCommas(number: string): string {
  const r = /(\d+)(\d{3})/;

  while (r.test(number)) {
    number = number.replace(r, '$1,$2');
  }

  return number;
}

function spanLeadingZeroes4(n: string): string {
  n = n.replace(/^(0{1,})([1-9]+)$/, '<span class="parse-error">$1</span>$2');
  n = n.replace(/^(0{1,})(0)$/, '<span class="parse-error">$1</span>$2');

  return n;
}

/*
 * A helper function to compact an array
 */
function compact(address: string[], slice: number[]) {
  const s1 = [];
  const s2 = [];
  let i;

  for (i = 0; i < address.length; i++) {
    if (i < slice[0]) {
      s1.push(address[i]);
    } else if (i > slice[1]) {
      s2.push(address[i]);
    }
  }

  return s1.concat(['compact']).concat(s2);
}

function paddedHex(octet: string): string {
  return sprintf('%04x', parseInt(octet, 16));
}

function unsignByte(b: number) {
  // eslint-disable-next-line no-bitwise
  return b & 0xff;
}


interface SixToFourProperties {
  prefix: string;
  gateway: string;
}

interface TeredoProperties {
  prefix: string;
  server4: string;
  client4: string;
  flags: string;
  coneNat: boolean;
  microsoft: {
    reserved: boolean;
    universalLocal: boolean;
    groupIndividual: boolean;
    nonce: string;
  };
  udpPort: string;
}

/**
 * Represents an IPv6 address
 * @class Address6
 * @param {string} address - An IPv6 address string
 * @param {number} [groups=8] - How many octets to parse
 * @example
 * var address = new Address6('2001::/32');
 */
export class Address6 {
  address4?: Address4;
  address: string;
  addressMinusSuffix: string = '';
  elidedGroups?: number;
  elisionBegin?: number;
  elisionEnd?: number;
  groups: number;
  parsedAddress4?: string;
  parsedAddress: string[];
  parsedSubnet: string = '';
  subnet: string = '/128';
  subnetMask: number = 128;
  v4: boolean = false;
  zone: string = '';

  constructor(address: string, optionalGroups?: number) {
    if (optionalGroups === undefined) {
      this.groups = constants6.GROUPS;
    } else {
      this.groups = optionalGroups;
    }

    this.address = address;

    const subnet = constants6.RE_SUBNET_STRING.exec(address);

    if (subnet) {
      this.parsedSubnet = subnet[0].replace('/', '');
      this.subnetMask = parseInt(this.parsedSubnet, 10);
      this.subnet = `/${this.subnetMask}`;

      if (
        Number.isNaN(this.subnetMask) ||
        this.subnetMask < 0 ||
        this.subnetMask > constants6.BITS
      ) {
        throw new AddressError('Invalid subnet mask.');
      }

      address = address.replace(constants6.RE_SUBNET_STRING, '');
    } else if (/\//.test(address)) {
      throw new AddressError('Invalid subnet mask.');
    }

    const zone = constants6.RE_ZONE_STRING.exec(address);

    if (zone) {
      this.zone = zone[0];

      address = address.replace(constants6.RE_ZONE_STRING, '');
    }

    this.addressMinusSuffix = address;

    this.parsedAddress = this.parse(this.addressMinusSuffix);
  }

  static isValid(address: string): boolean {
    try {
      // eslint-disable-next-line no-new
      new Address6(address);

      return true;
    } catch (e) {
      return false;
    }
  }

  /**
   * Convert a BigInteger to a v6 address object
   * @memberof Address6
   * @static
   * @param {BigInteger} bigInteger - a BigInteger to convert
   * @returns {Address6}
   * @example
   * var bigInteger = new BigInteger('1000000000000');
   * var address = Address6.fromBigInteger(bigInteger);
   * address.correctForm(); // '::e8:d4a5:1000'
   */
  static fromBigInteger(bigInteger: BigInteger): Address6 {
    const hex = bigInteger.toString(16).padStart(32, '0');
    const groups = [];
    let i;

    for (i = 0; i < constants6.GROUPS; i++) {
      groups.push(hex.slice(i * 4, (i + 1) * 4));
    }

    return new Address6(groups.join(':'));
  }

  /**
   * Convert a URL (with optional port number) to an address object
   * @memberof Address6
   * @static
   * @param {string} url - a URL with optional port number
   * @example
   * var addressAndPort = Address6.fromURL('http://[ffff::]:8080/foo/');
   * addressAndPort.address.correctForm(); // 'ffff::'
   * addressAndPort.port; // 8080
   */
  static fromURL(url: string) {
    let host: string;
    let port: string | number | null = null;
    let result: string[] | null;

    // If we have brackets parse them and find a port
    if (url.indexOf('[') !== -1 && url.indexOf(']:') !== -1) {
      result = constants6.RE_URL_WITH_PORT.exec(url);

      if (result === null) {
        return {
          error: 'failed to parse address with port',
          address: null,
          port: null,
        };
      }

      host = result[1];
      port = result[2];
      // If there's a URL extract the address
    } else if (url.indexOf('/') !== -1) {
      // Remove the protocol prefix
      url = url.replace(/^[a-z0-9]+:\/\//, '');

      // Parse the address
      result = constants6.RE_URL.exec(url);

      if (result === null) {
        return {
          error: 'failed to parse address from URL',
          address: null,
          port: null,
        };
      }

      host = result[1];
      // Otherwise just assign the URL to the host and let the library parse it
    } else {
      host = url;
    }

    // If there's a port convert it to an integer
    if (port) {
      port = parseInt(port, 10);

      // squelch out of range ports
      if (port < 0 || port > 65536) {
        port = null;
      }
    } else {
      // Standardize `undefined` to `null`
      port = null;
    }

    return {
      address: new Address6(host),
      port,
    };
  }

  /**
   * Create an IPv6-mapped address given an IPv4 address
   * @memberof Address6
   * @static
   * @param {string} address - An IPv4 address string
   * @returns {Address6}
   * @example
   * var address = Address6.fromAddress4('192.168.0.1');
   * address.correctForm(); // '::ffff:c0a8:1'
   * address.to4in6(); // '::ffff:192.168.0.1'
   */
  static fromAddress4(address: string): Address6 {
    const address4 = new Address4(address);

    const mask6 = constants6.BITS - (constants4.BITS - address4.subnetMask);

    return new Address6(`::ffff:${address4.correctForm()}/${mask6}`);
  }

  /**
   * Return an address from ip6.arpa form
   * @memberof Address6
   * @static
   * @param {string} arpaFormAddress - an 'ip6.arpa' form address
   * @returns {Adress6}
   * @example
   * var address = Address6.fromArpa(e.f.f.f.3.c.2.6.f.f.f.e.6.6.8.e.1.0.6.7.9.4.e.c.0.0.0.0.1.0.0.2.ip6.arpa.)
   * address.correctForm(); // '2001:0:ce49:7601:e866:efff:62c3:fffe'
   */
  static fromArpa(arpaFormAddress: string): Address6 {
    // remove ending ".ip6.arpa." or just "."
    let address = arpaFormAddress.replace(/(\.ip6\.arpa)?\.$/, '');
    const semicolonAmount = 7;

    // correct ip6.arpa form with ending removed will be 63 characters
    if (address.length !== 63) {
      throw new AddressError("Invalid 'ip6.arpa' form.");
    }

    const parts = address.split('.').reverse();

    for (let i = semicolonAmount; i > 0; i--) {
      const insertIndex = i * 4;
      parts.splice(insertIndex, 0, ':');
    }

    address = parts.join('');

    return new Address6(address);
  }

  /**
   * Return the Microsoft UNC transcription of the address
   * @memberof Address6
   * @instance
   * @returns {String} the Microsoft UNC transcription of the address
   */
  microsoftTranscription(): string {
    return sprintf('%s.ipv6-literal.net', this.correctForm().replace(/:/g, '-'));
  }

  /**
   * Return the first n bits of the address, defaulting to the subnet mask
   * @memberof Address6
   * @instance
   * @param {number} [mask=subnet] - the number of bits to mask
   * @returns {String} the first n bits of the address as a string
   */
  mask(mask: number = this.subnetMask): string {
    return this.getBitsBase2(0, mask);
  }

  /**
   * Return the number of possible subnets of a given size in the address
   * @memberof Address6
   * @instance
   * @param {number} [size=128] - the subnet size
   * @returns {String}
   */
  // TODO: probably useful to have a numeric version of this too
  possibleSubnets(subnetSize: number = 128): string {
    const availableBits = constants6.BITS - this.subnetMask;
    const subnetBits = Math.abs(subnetSize - constants6.BITS);
    const subnetPowers = availableBits - subnetBits;

    if (subnetPowers < 0) {
      return '0';
    }

    return addCommas(new BigInteger('2', 10).pow(subnetPowers).toString(10));
  }

  /**
   * Helper function getting start address.
   * @memberof Address6
   * @instance
   * @returns {BigInteger}
   */
  _startAddress(): BigInteger {
    return new BigInteger(this.mask() + '0'.repeat(constants6.BITS - this.subnetMask), 2);
  }

  /**
   * The first address in the range given by this address' subnet
   * Often referred to as the Network Address.
   * @memberof Address6
   * @instance
   * @returns {Address6}
   */
  startAddress(): Address6 {
    return Address6.fromBigInteger(this._startAddress());
  }

  /**
   * The first host address in the range given by this address's subnet ie
   * the first address after the Network Address
   * @memberof Address6
   * @instance
   * @returns {Address6}
   */
  startAddressExclusive(): Address6 {
    const adjust = new BigInteger('1');
    return Address6.fromBigInteger(this._startAddress().add(adjust));
  }

  /**
   * Helper function getting end address.
   * @memberof Address6
   * @instance
   * @returns {BigInteger}
   */
  _endAddress(): BigInteger {
    return new BigInteger(this.mask() + '1'.repeat(constants6.BITS - this.subnetMask), 2);
  }

  /**
   * The last address in the range given by this address' subnet
   * Often referred to as the Broadcast
   * @memberof Address6
   * @instance
   * @returns {Address6}
   */
  endAddress(): Address6 {
    return Address6.fromBigInteger(this._endAddress());
  }

  /**
   * The last host address in the range given by this address's subnet ie
   * the last address prior to the Broadcast Address
   * @memberof Address6
   * @instance
   * @returns {Address6}
   */
  endAddressExclusive(): Address6 {
    const adjust = new BigInteger('1');
    return Address6.fromBigInteger(this._endAddress().subtract(adjust));
  }

  /**
   * Return the scope of the address
   * @memberof Address6
   * @instance
   * @returns {String}
   */
  getScope(): string {
    let scope = constants6.SCOPES[this.getBits(12, 16).intValue()];

    if (this.getType() === 'Global unicast' && scope !== 'Link local') {
      scope = 'Global';
    }

    return scope || 'Unknown';
  }

  /**
   * Return the type of the address
   * @memberof Address6
   * @instance
   * @returns {String}
   */
  getType(): string {
    for (const subnet of Object.keys(constants6.TYPES)) {
      if (this.isInSubnet(new Address6(subnet))) {
        return constants6.TYPES[subnet] as string;
      }
    }

    return 'Global unicast';
  }

  /**
   * Return the bits in the given range as a BigInteger
   * @memberof Address6
   * @instance
   * @returns {BigInteger}
   */
  getBits(start: number, end: number): BigInteger {
    return new BigInteger(this.getBitsBase2(start, end), 2);
  }

  /**
   * Return the bits in the given range as a base-2 string
   * @memberof Address6
   * @instance
   * @returns {String}
   */
  getBitsBase2(start: number, end: number): string {
    return this.binaryZeroPad().slice(start, end);
  }

  /**
   * Return the bits in the given range as a base-16 string
   * @memberof Address6
   * @instance
   * @returns {String}
   */
  getBitsBase16(start: number, end: number): string {
    const length = end - start;

    if (length % 4 !== 0) {
      throw new Error('Length of bits to retrieve must be divisible by four');
    }

    return this.getBits(start, end)
      .toString(16)
      .padStart(length / 4, '0');
  }

  /**
   * Return the bits that are s